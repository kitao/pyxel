<!DOCTYPE html>
<html lang="en" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pyxel Code Maker (Starter)</title>

    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com/3.4.17"></script>

    <!-- Ace Editor (+ language tools for autocompletion) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.6/ext-language_tools.min.js"></script>

    <!-- Pyxel (Pyodide/WASM runtime helper) -->
    <script src="https://cdn.jsdelivr.net/gh/kitao/pyxel@2.5.9/wasm/pyxel.js"></script>

    <style type="text/tailwindcss">
      @layer components {
        .page {
          @apply bg-gray-900 text-gray-100 antialiased;
        }
        .toolbar {
          @apply flex items-center gap-2 bg-gray-800 p-2 border-gray-700 border-b;
        }
        .btn {
          @apply bg-gray-700 hover:bg-gray-600 px-3 py-1 border border-gray-600 rounded-md min-w-[3.5rem] font-medium text-gray-300 text-xs text-center;
        }
        .btn-primary {
          @apply bg-indigo-600 hover:bg-indigo-500 border-indigo-500;
        }
        .switchbar {
          @apply flex items-center gap-2 bg-gray-800 px-3 py-1.5 border-gray-700 border-b;
        }
        .switch-btn {
          @apply hover:bg-gray-700 px-2 py-1 rounded-md font-medium text-gray-300 text-xs;
        }
        .switch-btn.active {
          @apply bg-indigo-600 text-white;
        }
        .pane-title {
          @apply px-3 py-1 border-gray-700 border-b font-semibold text-gray-300 text-xs tracking-wide;
        }
        .tool-title {
          @apply mr-2 font-semibold text-gray-200 text-2xl tracking-tight select-none;
        }
        .seg {
          @apply flex items-center bg-gray-900 border border-gray-600 rounded-lg divide-x divide-gray-700 overflow-hidden;
        }
        .seg-btn {
          @apply flex-1 bg-gray-900 px-3 py-1 border-none focus:outline-none min-w-[2rem] font-medium text-gray-300 text-xs text-center;
        }
        .seg-active {
          @apply bg-slate-600 text-white;
        }
      }
    </style>
    <style>
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      .no-scrollbar {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
    </style>
  </head>

  <body class="h-full page">
    <div class="flex h-full min-h-0">
      <!-- LEFT SIDE (menu + editor/resource) -->
      <div
        class="flex flex-col flex-grow border-gray-800 border-r w-1/2 max-w-[50%] min-h-0"
      >
        <!-- Toolbar: Title / Load / Save / [Code | Resources] / Run / Stop -->
        <div class="toolbar">
          <div class="tool-title">Pyxel Code Maker</div>
          <!-- Control groups wrapper (takes remaining horizontal space, right-aligned) -->
          <div class="flex flex-1 justify-end items-center min-w-0">
            <!-- Left group: Load / Save -->
            <div class="flex items-center gap-2">
              <button id="loadBtn" class="btn" title="Load project folder">
                Load
              </button>
              <button id="saveCurrentBtn" class="btn" title="Save current file">
                Save
              </button>
            </div>
            <!-- Center group: Code / Res (no explicit center) -->
            <div class="flex items-center px-6">
              <div class="seg" role="group" aria-label="Edit target">
                <button
                  id="codeTabBtn"
                  class="seg-btn seg-active"
                  type="button"
                  aria-pressed="true"
                  title="Edit Python code"
                >
                  Code
                </button>
                <button
                  id="resTabBtn"
                  class="seg-btn"
                  type="button"
                  aria-pressed="false"
                  title="Edit Pyxel resources"
                >
                  Res
                </button>
              </div>
            </div>
            <!-- Right group: Run -->
            <div class="flex items-center gap-2">
              <button id="runBtn" class="btn" title="Run (Ctrl/âŒ˜+Enter)">
                Run
              </button>
            </div>
          </div>
        </div>

        <!-- Code pane -->
        <div id="codePane" class="flex flex-1 min-h-0">
          <div id="editor" class="w-full h-full"></div>
        </div>

        <!-- Resource pane -->
        <div id="resPane" class="hidden flex-1 min-h-0">
          <iframe
            id="pyxelEditorFrame"
            class="border-0 w-full h-full"
            title="Pyxel Resource Editor"
          ></iframe>
        </div>
      </div>

      <!-- RIGHT SIDE (preview only) -->
      <div class="flex flex-col flex-1 min-h-0">
        <iframe
          id="runtimeFrame"
          class="flex-1 bg-black border-0 w-full h-full min-h-0"
          title="Pyxel Runtime"
        ></iframe>
      </div>
    </div>

    <script>
      // -------------------------------------------------
      // Project state (only 2 logical files)
      // -------------------------------------------------
      // - main.py (text, editable in Ace)
      // - first .pyxres (binary as base64, edited in pyxel-editor iframe)
      const project = new Map(); // path -> { handle?, content, kind:'file'|'dir' }
      let projectRootHandle = null;
      let mainPyPath = "main.py";
      let resPath = null; // e.g. "assets.pyxres"
      let currentMode = "code"; // "code" or "res"

      // -------------------------------------------------
      // Ace Editor setup
      // -------------------------------------------------
      const editor = ace.edit("editor");
      editor.setTheme("ace/theme/monokai");
      editor.session.setMode("ace/mode/python");
      editor.setOptions({
        fontSize: "14px",
        showPrintMargin: false,
        highlightActiveLine: true,
        enableBasicAutocompletion: true,
        enableLiveAutocompletion: true,
        enableSnippets: true,
      });

      const pyxelCompleter = {
        getCompletions(editor, session, pos, prefix, callback) {
          const words = [
            "pyxel.init",
            "pyxel.run",
            "pyxel.quit",
            "pyxel.cls",
            "pyxel.text",
            "pyxel.pix",
            "pyxel.line",
            "pyxel.rect",
            "pyxel.rectb",
            "pyxel.circ",
            "pyxel.circb",
            "pyxel.blt",
            "pyxel.btn",
            "pyxel.btnp",
            "pyxel.btnr",
            "pyxel.KEY_Q",
            "pyxel.KEY_SPACE",
          ];
          callback(
            null,
            words.map((w) => ({ caption: w, value: w, meta: "pyxel" }))
          );
        },
      };
      ace.require("ace/ext/language_tools").addCompleter(pyxelCompleter);

      // -------------------------------------------------
      // DOM elements
      // -------------------------------------------------
      const codePane = document.getElementById("codePane");
      const resPane = document.getElementById("resPane");
      const codeTabBtn = document.getElementById("codeTabBtn");
      const resTabBtn = document.getElementById("resTabBtn");

      const runtimeFrame = document.getElementById("runtimeFrame");
      const pyxelEditorFrame = document.getElementById("pyxelEditorFrame");

      // Load the two child pages in iframes
      pyxelEditorFrame.src = "./pyxel-editor.html";
      runtimeFrame.src = "./pyxel-screen.html";

      // -------------------------------------------------
      // Helpers to read/write files (File System Access API)
      // -------------------------------------------------
      async function readFileHandle(fileHandle) {
        const file = await fileHandle.getFile();
        const buf = await file.arrayBuffer();
        return new Uint8Array(buf);
      }

      async function readTextHandle(fileHandle) {
        const file = await fileHandle.getFile();
        return await file.text();
      }

      async function traverseDir(dirHandle, base = "") {
        for await (const [name, handle] of dirHandle.entries()) {
          const rel = base ? base + "/" + name : name;
          if (handle.kind === "directory") {
            project.set(rel, { kind: "dir", handle });
            await traverseDir(handle, rel);
          } else if (handle.kind === "file") {
            let content;
            if (/\.(py|txt|md|mml)$/i.test(name)) {
              content = await readTextHandle(handle);
            } else {
              // Non-text file (ex: .pyxres) -> base64
              const bytes = await readFileHandle(handle);
              let bin = "";
              for (let i = 0; i < bytes.length; i++) {
                bin += String.fromCharCode(bytes[i]);
              }
              content = btoa(bin);
            }
            project.set(rel, { kind: "file", handle, content });

            // Detect main.py
            if (!mainPyPath && /(^|\/)main\.py$/i.test(rel)) {
              mainPyPath = rel;
            }

            // Detect first .pyxres
            if (!resPath && /\.pyxres$/i.test(name)) {
              resPath = rel;
            }
          }
        }
      }

      async function writeBackFile(path) {
        const meta = project.get(path);
        if (!meta || meta.kind !== "file" || !meta.handle) return;
        const writable = await meta.handle.createWritable();
        if (/\.(py|txt|md|mml)$/i.test(path)) {
          // text
          await writable.write(meta.content ?? "");
        } else {
          // base64 -> binary
          const b64 = meta.content ?? "";
          const bin = atob(b64);
          const bytes = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; i++) {
            bytes[i] = bin.charCodeAt(i);
          }
          await writable.write(bytes);
        }
        await writable.close();
      }

      // -------------------------------------------------
      // Pane switching
      // -------------------------------------------------
      function renderMode() {
        if (currentMode === "code") {
          // show code pane
          codePane.classList.remove("hidden");
          resPane.classList.add("hidden");

          // segmented toggle visual + accessibility (Code active)
          codeTabBtn.classList.add("seg-active");
          resTabBtn.classList.remove("seg-active");
          codeTabBtn.setAttribute("aria-pressed", "true");
          resTabBtn.setAttribute("aria-pressed", "false");

          // load python text into Ace
          const meta = project.get(mainPyPath);
          editor.setValue(meta?.content ?? "", -1);
          setTimeout(() => editor.resize(), 0);
        } else {
          // show resource pane
          codePane.classList.add("hidden");
          resPane.classList.remove("hidden");

          // segmented toggle visual + accessibility (Resources active)
          codeTabBtn.classList.remove("seg-active");
          resTabBtn.classList.add("seg-active");
          codeTabBtn.setAttribute("aria-pressed", "false");
          resTabBtn.setAttribute("aria-pressed", "true");

          // send current resource data to the resource iframe
          if (resPath) {
            const meta = project.get(resPath);
            if (meta) {
              const payload = {
                type: "open",
                path: resPath,
                base64: meta.content || "",
              };
              const f = pyxelEditorFrame;
              const post = () => {
                try {
                  f.contentWindow?.postMessage(payload, "*");
                } catch (e) {
                  console.warn(e);
                }
              };
              if (f.contentWindow) post();
              else f.onload = post;
            }
          }
        }
      }

      codeTabBtn.addEventListener("click", () => {
        currentMode = "code";
        renderMode();
      });

      resTabBtn.addEventListener("click", () => {
        currentMode = "res";
        renderMode();
      });

      // Save current editor buffer back into project map
      async function saveCurrentToMemory() {
        if (currentMode === "code") {
          const meta = project.get(mainPyPath);
          if (meta) {
            meta.content = editor.getValue();
            project.set(mainPyPath, meta);
          }
        } else if (currentMode === "res") {
          // In future: receive updated .pyxres data from pyxelEditorFrame via postMessage
        }
      }

      // -------------------------------------------------
      // Run / Stop preview
      // -------------------------------------------------
      let playerObjectUrl = null;

      function getActiveCode() {
        // Prefer main.py content from project, fallback to editor buffer
        if (mainPyPath && project.has(mainPyPath)) {
          const meta = project.get(mainPyPath);
          return meta?.content ?? editor.getValue();
        }
        return editor.getValue();
      }

      function getResourceBase64() {
        if (resPath && project.has(resPath)) {
          return project.get(resPath).content || "";
        }
        return "";
      }

      function buildPlayerHTML() {
        // This mini-runner expects pyxel.js to provide runPyxelAppFromCode(code, resBase64)
        return (
          '<!doctype html><html><head><meta charset=\\"utf-8\\">' +
          '<meta name=\\"viewport\\" content=\\"width=device-width, initial-scale=1\\">' +
          "<style>html,body{height:100%;margin:0;background:#000;color:#ccc;font-family:monospace;font-size:12px;}#root{height:100%}</style>" +
          '<script src=\\"https://cdn.jsdelivr.net/gh/kitao/pyxel/wasm/pyxel.js\\"><\\/script>' +
          '</head><body><div id=\\"root\\"></div><script>' +
          "(async () => {" +
          "  const code = sessionStorage.getItem('pyxelCode') || '';" +
          "  const res = sessionStorage.getItem('pyxelResource') || '';" +
          "  try { window.resetPyxel = () => location.reload(); } catch(e) { console.error(e); }" +
          "  if (window.runPyxelAppFromCode) {" +
          "    window.runPyxelAppFromCode(code, res);" +
          "  } else {" +
          "    console.log('runPyxelAppFromCode() is not defined yet');" +
          "  }" +
          "})();" +
          "<\\/script></body></html>"
        );
      }

      async function runApp() {
        await saveCurrentToMemory();
        sessionStorage.setItem("pyxelCode", getActiveCode());
        sessionStorage.setItem("pyxelResource", getResourceBase64());

        if (playerObjectUrl) URL.revokeObjectURL(playerObjectUrl);
        const blob = new Blob([buildPlayerHTML()], { type: "text/html" });
        playerObjectUrl = URL.createObjectURL(blob);
        runtimeFrame.src = playerObjectUrl;
      }

      function stopApp() {
        if (playerObjectUrl) {
          URL.revokeObjectURL(playerObjectUrl);
          playerObjectUrl = null;
        }
        runtimeFrame.src = "about:blank";
      }

      // -------------------------------------------------
      // Open / Save project via File System Access API
      // -------------------------------------------------
      async function openProjectFolder() {
        try {
          project.clear();
          mainPyPath = "main.py";
          resPath = null;
          projectRootHandle = await window.showDirectoryPicker({
            mode: "readwrite",
          });
          await traverseDir(projectRootHandle);

          // Ensure there is at least one main.py
          if (!project.has(mainPyPath)) {
            const starter = `import pyxel

pyxel.init(160, 120)

def update():
  if pyxel.btnp(pyxel.KEY_Q):
    pyxel.quit()

def draw():
  pyxel.cls(0)
  pyxel.text(40, 56, 'Hello, Pyxel!', 10)

pyxel.run(update, draw)
`;
            project.set(mainPyPath, {
              kind: "file",
              handle: null,
              content: starter,
            });
          }

          renderMode();
        } catch (e) {
          console.warn("Folder open cancelled or not supported", e);
        }
      }

      async function saveCurrentFile() {
        await saveCurrentToMemory();
        if (currentMode === "code" && mainPyPath) {
          await writeBackFile(mainPyPath);
        } else if (currentMode === "res" && resPath) {
          await writeBackFile(resPath);
        }
      }

      // -------------------------------------------------
      // Toolbar/keyboard wiring
      // -------------------------------------------------
      document
        .getElementById("loadBtn")
        ?.addEventListener("click", openProjectFolder);
      document
        .getElementById("saveCurrentBtn")
        ?.addEventListener("click", saveCurrentFile);
      document.getElementById("runBtn")?.addEventListener("click", runApp);
      document.getElementById("stopBtn")?.addEventListener("click", stopApp);

      document.addEventListener("keydown", async (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === "s") {
          e.preventDefault();
          await saveCurrentFile();
        } else if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
          e.preventDefault();
          runApp();
        } else if (e.key === "Escape") {
          e.preventDefault();
          stopApp();
        }
      });

      // -------------------------------------------------
      // Initial buffer (in-memory main.py only)
      // -------------------------------------------------
      const starter = `import pyxel

pyxel.init(160, 120)

def update():
  if pyxel.btnp(pyxel.KEY_Q):
    pyxel.quit()

def draw():
  pyxel.cls(0)
  pyxel.text(40, 56, 'Hello, Pyxel!', 10)

pyxel.run(update, draw)
`;
      project.set(mainPyPath, { kind: "file", handle: null, content: starter });

      // Initial render: show code view
      renderMode();

      // Warn if File System Access API unsupported
      if (!("showDirectoryPicker" in window)) {
        document
          .getElementById("loadBtn")
          ?.setAttribute(
            "title",
            "Your browser may not support the File System Access API"
          );
      }
    </script>
  </body>
</html>
